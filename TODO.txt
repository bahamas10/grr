# TODO

- `grr --integrate,-I` that checks for approvals, does the integration,
  and then calls `grrDelete`.
- change <parenthetical> to being an *option*, makes it clearer how to update
  it later:
        grr ISSUE
        ...
        grr -p "my parenthetical that I remembered to add later"
- doc the opinions and expected workflow in README.md
- eslint
- `grr -D` may delete other non-grr branch details, which isn't right
- --dry-run support
- --commit
- trace logging to file and less verbose output:
    - CONFIG_FILE and CACHE_FILE to move under ~/.grr: ~/.grr/config
      ~/.grr/cache.json. Maybe don't need to.
    - pass through arg.console that supports `console.{log,error}` and writes
      to the log file (at info level) as well
    - trace logging to ~/.grr/logs/$timestamp.log
    - put this all in logging.js
    - grr regular process to clean out old old log files
    - `grr --last-log` to cat last log file
- `grr -D` to check that all commits have been pushed to Gerrit, else require
  a -f
- support an option (in config and per branch) to push to a remote GH branch
  as well for every `grr`. Then have some of the GH branch utilities
  (nicer full diff, seeing individual commits as they were made, ability to
  use jenkins.joyent.us `TRY_BRANCH`)
- support pulling ticket title from smartos.org/bugview for public issues
  (then don't have to be internal Joyent Eng to use `grr`)
- perhaps add draft support: `git push origin HEAD:refs/drafts/master`
  This makes a "Draft" CR that only those added as reviewers can see. I
  don't know if there are other implications.



# scenarios

## scenario: simple single change for review

Uncommited changes:

    [~/src/myproject (master)]$ git diff
    ...

Get a review of them easily:

    [~/src/myproject (master)]$ grr --commit TOOLS-123
    Issue: TOOLS-123 add feature X
    Creating branch for CR: grr/TOOLS-123
    Commiting local changes:
        ...indented 'git commit' output
    Creating CR:
        ...indented 'git push' output (this may do the full grr/auto/$issue dance)
    CR: 42 <https://cr.joyent.us/42>
    [~/src/myproject (grr/TOOLS-123)]$

Then get reviews and click in the web UI to integrate it. When done, can
cleanup:

    [~/src/myproject (grr/TOOLS-123)]$ grr --delete
    ... confirm we are on a 'grr/*' branch.
    ... *perhaps* confirm the CR is merged?
    Deleting branch for CR 42 <https://cr.joyent.us/42>.
    Deleting remote 'origin' branch:        # only if it is there
        ...indented 'git push origin :$branch' output
    Deleting branch 'grr/TOOLS-123':
        ...indented 'git branch -d' output. Do we need 'git branch -D'?


## scenario: prep for working on an issue, no changes yet to CR

    [~/src/myproject (master)]$ grr TOOLS-123
    Issue: TOOLS-123 add feature X
    Creating branch for CR: grr/TOOLS-123
    Not creating CR: no commits over master

## scenario: creating a CR while on a manual feature branch

    [~/src/myproject (TOOLS-123)]$ grr TOOLS-123
    Issue: TOOLS-123 add feature X
    Using current feature branch for CR: TOOLS-123
    Creating CR:
        ...indented grr/auto/$issue dance
    CR: 42 <https://cr.joyent.us/42>
    [~/src/myproject (TOOLS-123)]$


## scenario: updates to a created CR

You have a 'grr/TOOLS-123' branch (created as in the first scenario) and
have created an initial CR 42. Now you have made another commit on your local
feature branch and want to update the CR.

    [~/src/myproject (grr/TOOLS-123)]$ git commit -am "another change"
    [~/src/myproject (grr/TOOLS-123)]$ grr
    Updating CR 42 <https://cr.joyent.us/42> with local commits.
    Warning: You have uncommited changes. You can `grr --commit` or commit them.
    Updating CR 42:
        ...indented grr/auto/$issue log
    CR 42 patch set 2 added: <https://cr.joyent.us/42/2>

^^^ That will create a temporary branch in which to squash your commits and
push *that* to Gerrit. Then it deletes that temp branch.


## scenario: `grr TOOLS-123` when not on that branch locally

What happens if the user does `grr TOOLS-123` when not on the already created
branch for that. There are a few cases.

1. `grr/TOOLS-123` branch exists locally, currently on master.

        [~/src/myproject (master)]$ grr TOOLS-123
        grr: error: 'grr/TOOLS-123' branch already exists. Switch to it or use '--force'.

    TODO: add '-f,--force' for creating a new branch.

2. `grr/TOOLS-123` branch exists locally, currently on some other branch.

        [~/src/myproject (foo)]$ grr TOOLS-123
        grr: error: TOOLS-123 does not match the CR issue (TOOLS-124) for the current branch (grr/TOOLS-123)

3. `TOOLS-123` branch exists locally and was manually used for CR'ing that
   issue earlier. Don't want to have `grr` start searching all branch configs
   right now. So this is a foot gun. The result is that it'll create a new
   'grr/TOOLS-123' branch.

        [~/src/myproject (master)]$ grr TOOLS-123
        Issue: TOOLS-123 add feature X
        Creating branch for CR: grr/TOOLS-123
        Not creating CR: no commits over master
        [~/src/myproject (grr/TOOLS-123)]$

    TODO: add '-f,--force' for creating a new branch.
